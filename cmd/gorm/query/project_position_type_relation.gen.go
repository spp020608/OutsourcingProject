// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"Outsourcing/cmd/gorm/model"
)

func newProjectPositionTypeRelation(db *gorm.DB, opts ...gen.DOOption) projectPositionTypeRelation {
	_projectPositionTypeRelation := projectPositionTypeRelation{}

	_projectPositionTypeRelation.projectPositionTypeRelationDo.UseDB(db, opts...)
	_projectPositionTypeRelation.projectPositionTypeRelationDo.UseModel(&model.ProjectPositionTypeRelation{})

	tableName := _projectPositionTypeRelation.projectPositionTypeRelationDo.TableName()
	_projectPositionTypeRelation.ALL = field.NewAsterisk(tableName)
	_projectPositionTypeRelation.ID = field.NewInt64(tableName, "id")
	_projectPositionTypeRelation.ProjectID = field.NewInt64(tableName, "project_id")
	_projectPositionTypeRelation.PositionTypeID = field.NewInt64(tableName, "position_type_id")

	_projectPositionTypeRelation.fillFieldMap()

	return _projectPositionTypeRelation
}

type projectPositionTypeRelation struct {
	projectPositionTypeRelationDo

	ALL            field.Asterisk
	ID             field.Int64 // 关联表自增ID
	ProjectID      field.Int64 // 项目ID
	PositionTypeID field.Int64 // 项目所需的工程师类型ID，对应position_type表中的id字段

	fieldMap map[string]field.Expr
}

func (p projectPositionTypeRelation) Table(newTableName string) *projectPositionTypeRelation {
	p.projectPositionTypeRelationDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p projectPositionTypeRelation) As(alias string) *projectPositionTypeRelation {
	p.projectPositionTypeRelationDo.DO = *(p.projectPositionTypeRelationDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *projectPositionTypeRelation) updateTableName(table string) *projectPositionTypeRelation {
	p.ALL = field.NewAsterisk(table)
	p.ID = field.NewInt64(table, "id")
	p.ProjectID = field.NewInt64(table, "project_id")
	p.PositionTypeID = field.NewInt64(table, "position_type_id")

	p.fillFieldMap()

	return p
}

func (p *projectPositionTypeRelation) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *projectPositionTypeRelation) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 3)
	p.fieldMap["id"] = p.ID
	p.fieldMap["project_id"] = p.ProjectID
	p.fieldMap["position_type_id"] = p.PositionTypeID
}

func (p projectPositionTypeRelation) clone(db *gorm.DB) projectPositionTypeRelation {
	p.projectPositionTypeRelationDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p projectPositionTypeRelation) replaceDB(db *gorm.DB) projectPositionTypeRelation {
	p.projectPositionTypeRelationDo.ReplaceDB(db)
	return p
}

type projectPositionTypeRelationDo struct{ gen.DO }

type IProjectPositionTypeRelationDo interface {
	gen.SubQuery
	Debug() IProjectPositionTypeRelationDo
	WithContext(ctx context.Context) IProjectPositionTypeRelationDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IProjectPositionTypeRelationDo
	WriteDB() IProjectPositionTypeRelationDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IProjectPositionTypeRelationDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IProjectPositionTypeRelationDo
	Not(conds ...gen.Condition) IProjectPositionTypeRelationDo
	Or(conds ...gen.Condition) IProjectPositionTypeRelationDo
	Select(conds ...field.Expr) IProjectPositionTypeRelationDo
	Where(conds ...gen.Condition) IProjectPositionTypeRelationDo
	Order(conds ...field.Expr) IProjectPositionTypeRelationDo
	Distinct(cols ...field.Expr) IProjectPositionTypeRelationDo
	Omit(cols ...field.Expr) IProjectPositionTypeRelationDo
	Join(table schema.Tabler, on ...field.Expr) IProjectPositionTypeRelationDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IProjectPositionTypeRelationDo
	RightJoin(table schema.Tabler, on ...field.Expr) IProjectPositionTypeRelationDo
	Group(cols ...field.Expr) IProjectPositionTypeRelationDo
	Having(conds ...gen.Condition) IProjectPositionTypeRelationDo
	Limit(limit int) IProjectPositionTypeRelationDo
	Offset(offset int) IProjectPositionTypeRelationDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IProjectPositionTypeRelationDo
	Unscoped() IProjectPositionTypeRelationDo
	Create(values ...*model.ProjectPositionTypeRelation) error
	CreateInBatches(values []*model.ProjectPositionTypeRelation, batchSize int) error
	Save(values ...*model.ProjectPositionTypeRelation) error
	First() (*model.ProjectPositionTypeRelation, error)
	Take() (*model.ProjectPositionTypeRelation, error)
	Last() (*model.ProjectPositionTypeRelation, error)
	Find() ([]*model.ProjectPositionTypeRelation, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ProjectPositionTypeRelation, err error)
	FindInBatches(result *[]*model.ProjectPositionTypeRelation, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ProjectPositionTypeRelation) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IProjectPositionTypeRelationDo
	Assign(attrs ...field.AssignExpr) IProjectPositionTypeRelationDo
	Joins(fields ...field.RelationField) IProjectPositionTypeRelationDo
	Preload(fields ...field.RelationField) IProjectPositionTypeRelationDo
	FirstOrInit() (*model.ProjectPositionTypeRelation, error)
	FirstOrCreate() (*model.ProjectPositionTypeRelation, error)
	FindByPage(offset int, limit int) (result []*model.ProjectPositionTypeRelation, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IProjectPositionTypeRelationDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (p projectPositionTypeRelationDo) Debug() IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Debug())
}

func (p projectPositionTypeRelationDo) WithContext(ctx context.Context) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p projectPositionTypeRelationDo) ReadDB() IProjectPositionTypeRelationDo {
	return p.Clauses(dbresolver.Read)
}

func (p projectPositionTypeRelationDo) WriteDB() IProjectPositionTypeRelationDo {
	return p.Clauses(dbresolver.Write)
}

func (p projectPositionTypeRelationDo) Session(config *gorm.Session) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Session(config))
}

func (p projectPositionTypeRelationDo) Clauses(conds ...clause.Expression) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p projectPositionTypeRelationDo) Returning(value interface{}, columns ...string) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p projectPositionTypeRelationDo) Not(conds ...gen.Condition) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p projectPositionTypeRelationDo) Or(conds ...gen.Condition) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p projectPositionTypeRelationDo) Select(conds ...field.Expr) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p projectPositionTypeRelationDo) Where(conds ...gen.Condition) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p projectPositionTypeRelationDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IProjectPositionTypeRelationDo {
	return p.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (p projectPositionTypeRelationDo) Order(conds ...field.Expr) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p projectPositionTypeRelationDo) Distinct(cols ...field.Expr) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p projectPositionTypeRelationDo) Omit(cols ...field.Expr) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p projectPositionTypeRelationDo) Join(table schema.Tabler, on ...field.Expr) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p projectPositionTypeRelationDo) LeftJoin(table schema.Tabler, on ...field.Expr) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p projectPositionTypeRelationDo) RightJoin(table schema.Tabler, on ...field.Expr) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p projectPositionTypeRelationDo) Group(cols ...field.Expr) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p projectPositionTypeRelationDo) Having(conds ...gen.Condition) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p projectPositionTypeRelationDo) Limit(limit int) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p projectPositionTypeRelationDo) Offset(offset int) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p projectPositionTypeRelationDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p projectPositionTypeRelationDo) Unscoped() IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Unscoped())
}

func (p projectPositionTypeRelationDo) Create(values ...*model.ProjectPositionTypeRelation) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p projectPositionTypeRelationDo) CreateInBatches(values []*model.ProjectPositionTypeRelation, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p projectPositionTypeRelationDo) Save(values ...*model.ProjectPositionTypeRelation) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p projectPositionTypeRelationDo) First() (*model.ProjectPositionTypeRelation, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProjectPositionTypeRelation), nil
	}
}

func (p projectPositionTypeRelationDo) Take() (*model.ProjectPositionTypeRelation, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProjectPositionTypeRelation), nil
	}
}

func (p projectPositionTypeRelationDo) Last() (*model.ProjectPositionTypeRelation, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProjectPositionTypeRelation), nil
	}
}

func (p projectPositionTypeRelationDo) Find() ([]*model.ProjectPositionTypeRelation, error) {
	result, err := p.DO.Find()
	return result.([]*model.ProjectPositionTypeRelation), err
}

func (p projectPositionTypeRelationDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ProjectPositionTypeRelation, err error) {
	buf := make([]*model.ProjectPositionTypeRelation, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p projectPositionTypeRelationDo) FindInBatches(result *[]*model.ProjectPositionTypeRelation, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p projectPositionTypeRelationDo) Attrs(attrs ...field.AssignExpr) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p projectPositionTypeRelationDo) Assign(attrs ...field.AssignExpr) IProjectPositionTypeRelationDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p projectPositionTypeRelationDo) Joins(fields ...field.RelationField) IProjectPositionTypeRelationDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p projectPositionTypeRelationDo) Preload(fields ...field.RelationField) IProjectPositionTypeRelationDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p projectPositionTypeRelationDo) FirstOrInit() (*model.ProjectPositionTypeRelation, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProjectPositionTypeRelation), nil
	}
}

func (p projectPositionTypeRelationDo) FirstOrCreate() (*model.ProjectPositionTypeRelation, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProjectPositionTypeRelation), nil
	}
}

func (p projectPositionTypeRelationDo) FindByPage(offset int, limit int) (result []*model.ProjectPositionTypeRelation, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p projectPositionTypeRelationDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p projectPositionTypeRelationDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p projectPositionTypeRelationDo) Delete(models ...*model.ProjectPositionTypeRelation) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *projectPositionTypeRelationDo) withDO(do gen.Dao) *projectPositionTypeRelationDo {
	p.DO = *do.(*gen.DO)
	return p
}
